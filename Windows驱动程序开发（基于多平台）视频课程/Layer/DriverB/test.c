#include <ntddk.h>

typedef struct _DEVICE_EXTENSION 
{
	PDEVICE_OBJECT TargetDevice;
}DEVICE_EXTENSION, *PDEVICE_EXTENSION;

VOID Unload(IN PDRIVER_OBJECT DriverObject)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)DriverObject->DeviceObject->DeviceExtension;

	IoDetachDevice(pdx->TargetDevice);
	IoDeleteDevice(DriverObject->DeviceObject);

	KdPrint(("驱动B卸载\n"));
}

NTSTATUS Create(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	NTSTATUS status;
	KdPrint(("进入DriverB:Create\n"));
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->TargetDevice, Irp);
	KdPrint(("离开DriverB:Create\n"));
	return status;
}

NTSTATUS Close(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	NTSTATUS status;
	KdPrint(("进入DriverB:Close\n"));
	IoSkipCurrentIrpStackLocation(Irp);
	status = IoCallDriver(pdx->TargetDevice, Irp);
	KdPrint(("离开DriverB:Close\n"));
	return status;
}

NTSTATUS
IoCompleteRoutine(
_In_ PDEVICE_OBJECT DeviceObject,
_In_ PIRP Irp,
_In_reads_opt_(_Inexpressible_("varies")) PVOID Context
)
{

	PKEVENT pEvent = (PKEVENT)Context;
	KdPrint(("进入DriverB:IoCompleteRoutione\n"));
	if (Irp->PendingReturned)
	{
		KeSetEvent(pEvent, IO_NO_INCREMENT, FALSE);
	}
	KdPrint(("离开DriverB:IoCompleteRoutione\n"));

	return STATUS_MORE_PROCESSING_REQUIRED;
}

NTSTATUS Read(IN PDEVICE_OBJECT DeviceObject, IN PIRP Irp)
{
	PDEVICE_EXTENSION pdx = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;
	NTSTATUS status;
	KEVENT Event;
	KdPrint(("进入DriverB:Read\n"));
	//IoSkipCurrentIrpStackLocation(Irp);

	IoCopyCurrentIrpStackLocationToNext(Irp);
	KeInitializeEvent(&Event, NotificationEvent, FALSE);
	IoSetCompletionRoutine(Irp, IoCompleteRoutine, &Event, TRUE, TRUE, TRUE);

	status = IoCallDriver(pdx->TargetDevice, Irp);
	if (status == STATUS_PENDING)
	{
		KeWaitForSingleObject(&Event, Executive, KernelMode, FALSE, NULL);
	}

	IoCompleteRequest(Irp, IO_NO_INCREMENT);

	KdPrint(("离开DriverB:Read\n"));
	return STATUS_SUCCESS;
}

NTSTATUS DriverEntry(IN PDRIVER_OBJECT DriverObject, IN PUNICODE_STRING RegistryPath)
{
	NTSTATUS status;
	PDEVICE_OBJECT DeviceObject;
	PDEVICE_EXTENSION pdx;
	PDEVICE_OBJECT NextDevice;
	PFILE_OBJECT FileObject;
	UNICODE_STRING TargetDeviceName = RTL_CONSTANT_STRING(L"\\Device\\HelloDDK");
	KdPrint(("驱动B加载\n"));
	DriverObject->DriverUnload = Unload;
	DriverObject->MajorFunction[IRP_MJ_CREATE] = Create;
	DriverObject->MajorFunction[IRP_MJ_READ] = Read;
	DriverObject->MajorFunction[IRP_MJ_CLOSE] = Close;


	status = IoCreateDevice(DriverObject, sizeof(DEVICE_EXTENSION), NULL, FILE_DEVICE_UNKNOWN, FILE_AUTOGENERATED_DEVICE_NAME, FALSE, &DeviceObject);
	if (!NT_SUCCESS(status))
	{
		KdPrint(("设备创建失败%x\n", status));
		return status;
	}

	pdx = (PDEVICE_EXTENSION)DeviceObject->DeviceExtension;

	status = IoGetDeviceObjectPointer(&TargetDeviceName, FILE_ANY_ACCESS, &FileObject, &NextDevice);
	if (!NT_SUCCESS(status))
	{
		KdPrint(("设备获取失败%x\n", status));
		IoDeleteDevice(DeviceObject);
		return status;
	}

	pdx->TargetDevice = IoAttachDeviceToDeviceStack(DeviceObject, NextDevice);
	
	DeviceObject->Characteristics = pdx->TargetDevice->Characteristics;
	DeviceObject->DeviceType = pdx->TargetDevice->DeviceType;
	DeviceObject->Flags = pdx->TargetDevice->Flags;
	DeviceObject->Flags &= ~DO_DEVICE_INITIALIZING;

	ObDereferenceObject(FileObject);

	return STATUS_SUCCESS;
}